
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Worlds</title>
<style>
html {
  height: 100%;
}
img {
  display: none;
}
body {
  background: #000;
  overflow: hidden;
  padding: 0;
  margin: 0;
  width: 100%;
  height: 100%;
  text-align: center;
}
canvas {
  height: 100%;
  width: 100%;
  margin: auto;
}
</style>
<script>
  window.console = window.console || function(t) {};
</script>
<script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>
</head>
<body translate="no">

<script id="vertexShader" type="x-shader/x-vertex">#version 300 es
  precision mediump float;
in vec4 vPosition;
void main() {
	gl_Position = vPosition;
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">#version 300 es
  precision mediump float;
out vec4 fragColor;
  
uniform vec2 resolution;
uniform float time;
uniform vec4 mouse;
  
#define MAX_STEPS 140
#define MAX_DIST 50.
#define MIN_DIST .001

#define PI  		3.1415926
#define PI2 		6.2831853

#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))
#define isMouse() mouse.xy==vec2(0)
#define mx() isMouse() ? 0. : -(mouse.y / resolution.y * 1. - .5) * PI
#define my() isMouse() ? -1. : -(mouse.x / resolution.x * 1. - .5) * PI
#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)

#define S smoothstep

//iq of hsv2rgb
vec3 hsv2rgb( in vec3 c ) {
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
	return c.z * mix( vec3(1.0), rgb, c.y);
}

// iMouse pos function
vec3 get_mouse(vec3 ro) {
    ro.zy *= r2(mx());
    ro.zx *= r2(my());
    return ro;
}

float sdBox(vec3 p, vec3 s) {
    p = abs(p)-s;
	return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);
}

float sdGry(vec3 p, float s, float t, float b) {
    p *=s;
    float g = abs(dot(sin(p*1.25), cos(p.zxy))-b)/(s*1.25)-t;
    return g;
}

//global vars cause its just a demo
float g2,g3,g4,g5;
vec3 hitPoint;

vec2 GetDist(vec3 p) {
    vec2 res=vec2(1000.,0.);
    
    float spc = .6;
    float hlf = spc/2.;
    vec3 q = p;
    
    // move scene
    p.xy *= r2(p.z*.13);
    p.z += time*.2;
    p.y -= .3;

	float g1 = sdGry(p, 3.31, .03, 1.45);
    g2 = sdGry(p, 12.3, .03, .2);
    g3 = sdGry(p, 16.3, .03, .2);
    g4 = sdGry(p, 28.3, .03, .2);
    g5 = sdGry(p, 42.3, .03, .2);

    g1 -= (g2 *.5);
    g1 -= (g3 *.2);
    g1 -= (g4 *.2);
    g1 -= (g5 *.1);

    if(g1<res.x) res=vec2(g1*.6,1.);
    
    hitPoint = p;
    return res;
}

//Updated Marcher for doing any reflections
vec2 RayMarch(vec3 ro, vec3 rd) {
    float mat = 0.;
    float depth = 0.;
    for (int i = 0; i<MAX_STEPS;i++)
    {
     	vec3 pos = ro + depth * rd;
        vec2 dist = GetDist(pos);
        mat = dist.y;
        if(dist.x<MIN_DIST*depth) break;
        depth += dist.x*.8; 
        if(depth>MAX_DIST) break;
    }
    return vec2(depth,mat);
}

vec3 GetNormal(vec3 p) {
	float d = GetDist(p).x;
    vec2 e = vec2(.001, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy).x,
        GetDist(p-e.yxy).x,
        GetDist(p-e.yyx).x);
    
    return normalize(n);
}

// trying to get that rock sand texture on the asteroids.. 
// @Shane @iq Compact, self-contained version of IQ's 3D value noise function. 
float n3D(in vec3 p){
    
	const vec3 s = vec3(113, 157, 1);
	vec3 ip = floor(p); p -= ip; 
    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);
    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);
    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);
    h.xy = mix(h.xz, h.yw, p.y);
    return mix(h.x, h.y, p.z); // Range: [0, 1].
}
// 3D noise fBm.
float fBm(in vec3 p){
    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15; 
}

// Asteroid Material
// rock and rainbow lines 
// @BigWIngs video mostly with my twists
vec3 GetMaterial(vec3 p) {
    vec3 col = vec3(0.);
    vec3 n = GetNormal(p); 
    float clr = fBm(hitPoint*75.)*fBm(hitPoint*135.);
    float dif = n.y*.5+.5; 
    col += vec3(.4,.1,.002) * clr * dif;
    col *= S(-.06,.1,g2);
    float cks = S(-.02,-.03,g2);
    vec3 mate = hsv2rgb(vec3(p.y*.3,1.,.5))*1.25;	
    col += mate*cks*2.;   
    return col;
}

vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {
    vec3 f = normalize(l-p),
        r = normalize(cross(vec3(0,1,0), f)),
        u = cross(f,r),
        c = f*z,
        i = c + uv.x*r + uv.y*u,
        d = normalize(i);
    return d;
}
 
  void main( void ) {
    
    vec2 uv = (2.*gl_FragCoord.xy-resolution.xy)/max(resolution.x,resolution.y);

    vec3 col = vec3(0.);
    vec3 lp = vec3(0.);
    vec3 ro = vec3(0., 0., -3.5);
    ro = get_mouse(ro);
    
    vec3 rd = GetRayDir(uv, ro, lp, 1.);
    vec2 ray = RayMarch(ro, rd);

    if(ray.x<MAX_DIST) {
    	vec3 p = ro + rd * ray.x;
   		vec3 n = GetNormal(p);
        float diff = n.y*.5+.5; 
        if(ray.y==1.){
    	 	col += diff * GetMaterial(p);
        } 
    }

	  col = mix( col, vec3(.25,.25,.3), 1.-exp(-0.003*ray.x*ray.x*ray.x));
    
    col = pow(col, vec3(.4545));
    fragColor = vec4(col,1.0);
}
 

</script>
<script src="https://static.codepen.io/assets/common/stopExecutionOnTimeout-157cd5b220a5c80d4ff8e0e70ac069bffd87a61252088146915e8726e5d9f147.js"></script>
<script id="rendered-js">
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;} // Mouse Class //
class Mouse {
  constructor(element) {_defineProperty(this, "reset",



















    () => {
      this.x =
      ~~(document.documentElement.clientWidth, window.innerWidth || 0) / 2;
      this.y =
      ~~(document.documentElement.clientHeight, window.innerHeight || 0) / 2;
    });this.element = element || window;this.drag = false;this.x = ~~(document.documentElement.clientWidth, window.innerWidth || 0) / 2;this.y = ~~(document.documentElement.clientHeight, window.innerHeight || 0) / 2;this.pointer = this.pointer.bind(this);this.getCoordinates = this.getCoordinates.bind(this);this.events = ["mouseenter", "mousemove"];this.events.forEach(eventName => {this.element.addEventListener(eventName, this.getCoordinates);});this.element.addEventListener("mousedown", () => {this.drag = true;});this.element.addEventListener("mouseup", () => {this.drag = false;});}
  getCoordinates(event) {
    event.preventDefault();
    const x = event.pageX;
    const y = event.pageY;
    if (this.drag) {
      this.x = x;
      this.y = y;
    }
  }
  pointer() {
    return {
      x: this.x,
      y: this.y,
      z: this.drag };

  }}


// Boostrap for WebGL and Attaching Shaders //
// Fragment & Vertex Shaders in HTML window //
//
class Render {
  constructor() {_defineProperty(this, "createCanvas",







































































    name => {
      this.canvas =
      document.getElementById(name) || document.createElement("canvas");
      this.canvas.id = name;
      if (!document.getElementById(name)) {
        document.body.appendChild(this.canvas);
      }
      const context = this.canvas.getContext("webgl2");
      if (!context) {
        console.error("no webgl avaiable");
      }
      this.setViewport();
    });_defineProperty(this, "setViewport",

    () => {
      this.width = ~~(document.documentElement.clientWidth,
      window.innerWidth || 0);
      this.height = ~~(document.documentElement.clientHeight,
      window.innerHeight || 0);
      this.gl = this.canvas.getContext("webgl");
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.gl.viewport(0, 0, this.width, this.height);
      this.clearCanvas();
    });_defineProperty(this, "createShader",


    (type, source) => {
      const shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      const success = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);
      if (!success) {
        console.log(this.gl.getShaderInfoLog(shader));
        this.gl.deleteShader(shader);
        return false;
      }
      return shader;
    });_defineProperty(this, "createWebGL",

    (vertexSource, fragmentSource) => {
      // Setup Vertext/Fragment Shader functions
      this.vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
      this.fragmentShader = this.createShader(
      this.gl.FRAGMENT_SHADER,
      fragmentSource);


      // Setup Program and Attach Shader functions
      this.program = this.gl.createProgram();
      this.gl.attachShader(this.program, this.vertexShader);
      this.gl.attachShader(this.program, this.fragmentShader);
      this.gl.linkProgram(this.program);
      this.gl.useProgram(this.program);

      if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
        console.warn(
        "Unable to initialize the shader program: " +
        this.gl.getProgramInfoLog(this.program));

        return null;
      }

      // Create and Bind buffer //
      const buffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);

      this.gl.bufferData(
      this.gl.ARRAY_BUFFER,
      new Float32Array([-1, 1, -1, -1, 1, -1, 1, 1]),
      this.gl.STATIC_DRAW);


      const vPosition = this.gl.getAttribLocation(this.program, "vPosition");

      this.gl.enableVertexAttribArray(vPosition);
      this.gl.vertexAttribPointer(
      vPosition,
      2, // size: 2 components per iteration
      this.gl.FLOAT, // type: the data is 32bit floats
      false, // normalize: don't normalize the data
      0, // stride: 0 = move forward size * sizeof(type) each iteration to get the next position
      0 // start at the beginning of the buffer
      );

      this.clearCanvas();
      this.importUniforms();
    });_defineProperty(this, "clearCanvas",

    () => {
      this.gl.clearColor(0, 0, 0, 0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    });_defineProperty(this, "importUniforms",

    () => {
      const width = ~~(document.documentElement.clientWidth,
      window.innerWidth || 0);
      const height = ~~(document.documentElement.clientHeight,
      window.innerHeight || 0);
      this.resolution = new Float32Array([width, height]);
      this.gl.uniform2fv(
      this.gl.getUniformLocation(this.program, "resolution"),
      this.resolution);

      // get the uniform ins from the shader fragments
      this.ut = this.gl.getUniformLocation(this.program, "time");
      this.ms = this.gl.getUniformLocation(this.program, "mouse");
      this.rf = this.gl.getUniformLocation(this.program, "refl");
      this.sp = this.gl.getUniformLocation(this.program, "speed");
      this.rn = this.gl.getUniformLocation(this.program, "spacing");

      this.resolution = new Float32Array([this.canvas.width, this.canvas.height]);
      this.gl.uniform2fv(
      this.gl.getUniformLocation(this.program, "resolution"),
      this.resolution);


      this.gl.uniform1f(this.sp, this.speed);
      this.gl.uniform1f(this.rn, this.spacing);
      this.gl.uniform1f(this.rf, this.refl);
    });_defineProperty(this, "updateUniforms",

    () => {
      this.gl.uniform1f(this.ut, (Date.now() - this.start) / 1000);
      const mouse = this.mouse.pointer();
      this.umouse = this.hiRez ?
      [mouse.x, this.canvas.height - mouse.y / 2, 0] :
      [mouse.x, this.canvas.height - mouse.y / 2, 0];
      const factor = 0.15;
      this.tmouse[0] =
      this.tmouse[0] - (this.tmouse[0] - this.umouse[0]) * factor;
      this.tmouse[1] =
      this.tmouse[1] - (this.tmouse[1] - this.umouse[1]) * factor;
      this.tmouse[2] = mouse.z ? 1 : 0;
      this.gl.uniform4fv(this.ms, this.tmouse);

      this.gl.drawArrays(
      this.gl.TRIANGLE_FAN, // primitiveType
      0, // Offset
      4 // Count
      );
    });_defineProperty(this, "createGui",
    () => {
      this.options = {
        reflections: this.refl,
        strength: this.strength,
        speed: this.speed,
        spacing: this.spacing,
        hiRez: this.hiRez };

      this.gui = new dat.GUI();
      const folderRender = this.gui.addFolder("Render Options");
      // const folderColor = this.gui.addFolder("Color Options");
      // folderRender
      //   .add(this.options, "spacing", 4, 14)
      //   .step(1)
      //   .onFinishChange((value) => {
      //     this.spacing = value;
      //     this.gl.uniform1f(this.rn, this.spacing);
      //   });
      // folderRender
      //   .add(this.options, "speed", 0.0, 20)
      //   .step(0.01)
      //   .onFinishChange((value) => {
      //     this.speed = value;
      //     this.gl.uniform1f(this.sp, this.speed);
      //   });
      // folderRender.add(this.options, "reflections").onFinishChange((value) => {
      //   this.refl = value;
      //   this.gl.uniform1f(this.rf, this.refl ? 1 : 0);
      // });
      folderRender.add(this.options, "hiRez").onFinishChange(value => {
        this.hiRez = value;
        const e = window.document.createEvent("UIEvents");
        e.initUIEvent("resize", true, false, window, 0);
        window.dispatchEvent(e);
      });
    });_defineProperty(this, "init",
    () => {
      this.createWebGL(
      document.getElementById("vertexShader").textContent,
      document.getElementById("fragmentShader").textContent);

      this.renderLoop();
    });_defineProperty(this, "renderLoop",
    () => {
      this.updateUniforms();
      this.animation = window.requestAnimationFrame(this.renderLoop);
    });this.spacing = 6;this.speed = 0.5;this.refl = true;this.hiRez = false; // change for hi-rez output
    this.start = Date.now();this.mouse;this.frame = 0;this.umouse = [0.0, 0.0, 0.0, 0.0];this.tmouse = [0.0, 0.0, 0.0, 0.0]; // Setup WebGL canvas and surface object //
    // Make Canvas and get WebGl2 Context //
    let _width = this.width = ~~(document.documentElement.clientWidth, window.innerWidth || 0);let _height = this.height = ~~(document.documentElement.clientHeight, window.innerHeight || 0);const canvas = this.canvas = document.createElement("canvas");canvas.id = "GLShaders";if (!this.hiRez) {_width = ~~(_width * 0.5);_height = ~~(_height * 0.5);}canvas.width = _width;canvas.height = _height;this.mouse = new Mouse(canvas);document.body.appendChild(canvas);const gl = this.gl = canvas.getContext("webgl2");if (!gl) {console.warn("WebGL 2 is not available.");return;} // WebGl and WebGl2 Extension //
    this.gl.getExtension("OES_standard_derivatives");this.gl.getExtension("EXT_shader_texture_lod");this.gl.getExtension("OES_texture_float");this.gl.getExtension("WEBGL_color_buffer_float");this.gl.getExtension("OES_texture_float_linear");this.gl.viewport(0, 0, canvas.width, canvas.height);window.addEventListener("resize", () => {let width = ~~(document.documentElement.clientWidth, window.innerWidth || 0);let height = ~~(document.documentElement.clientHeight, window.innerHeight || 0);if (!this.hiRez) {width = ~~(width * 0.5);height = ~~(height * 0.5);}this.canvas.width = width;this.canvas.height = height;this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);this.resolution = new Float32Array([width, height]);this.gl.uniform2fv(this.gl.getUniformLocation(this.program, "resolution"), this.resolution);this.clearCanvas();}, false);this.init(); //this.createGui();
  } // Canvas Helper Function //
}const demo = new Render(document.body);
//# sourceURL=pen.js
    </script>
</body>
</html>
